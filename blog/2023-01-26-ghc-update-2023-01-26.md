---
slug: 2023-01-26-ghc-update
title: GHC DevX Update 2023-01-26
authors: [sylvain,doyougnu,luite,josh]
tags: [ghc]
---

This is the second biweekly update of the IOG GHC DevX team.
You can find the previous one [here](https://engineering.iog.io/2023-01-12-ghc-update).

## JS backend

### Template Haskell

Sylvain continued his work on the implementation of Template Haskell for the JS
backend.
He factorized the code from `iserv` and `libiserv` into the `ghci` library,
making GHC able to easily load and run the external interpreter server (`iserv`)
compiled into JavaScript in a NodeJS instance.
He modified GHC to avoid creating ByteCode objects (which are unsupported by the
JS backend) and to instead compile and link JavaScript codes.

It worked well so Template Haskell basically works with the JS backend now,
except for a few corner cases (e.g. one-shot mode) that should be fixed in the
coming days/weeks.

Luite modified Sylvain's JS code to fix support for Darwin and Windows. If you
want to test it, a draft merge request has been opened:
https://gitlab.haskell.org/ghc/ghc/-/merge_requests/9779

### JS backend in the browser tutorial

Josh published a tutorial about using code produced by the JS backend in a Web
page:
https://engineering.iog.io/2023-01-24-javascript-browser-tutorial


### Cabal support for js-sources

Sylvain added tests to his patch adding cabal support for the `js-sources`
stanza when GHC is used as a compiler (and not only when GHCJS is used as a
compiler), allowing the patch to be merged:
https://github.com/haskell/cabal/pull/8636

https://github.com/haskell/cabal/issues/8639 is still open though so be careful
if you try to use `js-sources`, they still don't work in some cases.


### JS backend CI

TODO: Jeff, CI MRs status

### FileStat

Josh opened an MR to match the layout of the JavaScript `fileStat` with the
layout of the equivalent struct defined in Emscripten's `stat.h`. This is needed
to ensure that hsc2hs features work correctly with this data type. Hsc2hs features
can peek at memory locations directly without using accessor functions, and the
memory locations are taken from the header file, hence the requirement to match
these layouts.

This MR only touches JavaScript files, so we're waiting on the approval of the
JS CI before continuing. For more information, see
https://gitlab.haskell.org/ghc/ghc/-/issues/22573

### JavaScript RTS refactor

Josh refactored parts of the GHC.StgToJS.Rts.Rts module, which previously had
special cases for the 0, 1, and 2-argument versions of the generated set of
JavaScript functions `h$cN{x1, x2, ..., xN}`. These cases were able to be
absorbed into the generalised n-argument generator function, allowing for a
few simplifications to the module's code.

Extra caching, in the form of lookup `Array`s, was also introduced for names
that were commonly used in the generated JavaScript ASTs. Previously, names
such as `x1` would require allocation each use, first allocating a `String`,
which was then converted to a GHC `FastString`, and finally wrapped in a JS
AST data constructor. Now, the resulting AST can be looked up directly from
the `Array`.

### JS EDSL

TODO: Jeff


### Blog posts

TODO: Luite (new blog posts about GHCJS)


### JS backend configuration issue in a Docker image

Sylvain debugged a configuration issue of GHC with the JS backend (see
[#22814](https://gitlab.haskell.org/ghc/ghc/-/issues/22814)).
The recommended way is to use the following command line:

```
emconfigure ./configure --target=js-unknown-ghcjs
```

where `emconfigure` is provided by the Emscripten project and sets appropriate
environment variables (CC, LD, AR...).

However in some cases it seems like these variables are set as follows:

```
CC=emcc
LD=emcc
...
```

in which case GHC's `configure` script will silently ignores them... and uses the
C compiler for the host platform instead (x86-64, aarch64...). As the C compiler
is only used for the CPP pass, it results in some inscrutable errors. In #22814
the error is due to `CSize` being inferred as a 64-bit type while it should be
32-bit for the JavaScript platform, leading to CSize values being passed as 2
arguments in FFI calls while the callee expects 1.

Calling `configure` with the right environment variables fixes the issue:

```
./configure CC=$(which emcc) LD=$(which emcc) --target=js-unknown-ghcjs
```


### Discussion about JS backend maturity

TODO: lower expectations about the JS/Wasm backends




## Compiler performance

### More-strict `break`

Josh did more investigation into the performance difference that introducing
some strictness into the `break` function would make. The STG and microbenchmarks
are very promising, but using the "compile cabal" benchmark, there doesn't seem
to be a noticable time difference caused by the change. In terms of memory, it
seems to reduce GC copying, but slightly increase overall allocations and total
memory usage.

It's likely that this optimisation would have the most benefit if applied in
isolated cases in GHC, if any pathological lazy cases are found.

## Misc

### Cross-compilation from Linux/Darwin to Windows

TODO: Sylvain (rebased old MR !9310, added missing stuff for Darwin, validated by romes on Darwin)

### Hadrian rules to build the Sphinx-based docs

TODO: Sylvain !9795
